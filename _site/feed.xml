<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://jimjshields.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://jimjshields.github.io/" rel="alternate" type="text/html" /><updated>2017-12-30T12:49:05-05:00</updated><id>http://jimjshields.github.io/</id><title type="html">Shields of Dreams</title><subtitle>Jim's blog. Programming, movies, data, etc.</subtitle><entry><title type="html">A (Really Brief) Intro to Natural Language Processing</title><link href="http://jimjshields.github.io/programming,/recurse/center,/nlp/2015/03/11/a-really-brief-intro-to-nlp.html" rel="alternate" type="text/html" title="A (Really Brief) Intro to Natural Language Processing" /><published>2015-03-11T00:00:00-04:00</published><updated>2015-03-11T00:00:00-04:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/nlp/2015/03/11/a-really-brief-intro-to-nlp</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/nlp/2015/03/11/a-really-brief-intro-to-nlp.html">&lt;p&gt;Hacker School: Week 10, Day 2&lt;/p&gt;

&lt;p&gt;It’s been far too long since the last post. I promised my check-in group — our daily time for talking about what we’re doing here — every day last week that I would write a blog post. I didn’t. But here it is, in all its glory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is Natural Language Processing?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;My brief sojourn into working with words — specifically, the Academy Award speeches — sparked an interest in all of the possibilities of combining programming and language. Everything I read and heard about this idea led me back to natural language processing. So, as is my custom, I went straight to &lt;a href=&quot;http://en.wikipedia.org/wiki/Natural_language_processing&quot;&gt;good old Wikipedia&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;“&lt;strong&gt;Natural language processing&lt;/strong&gt; (&lt;strong&gt;NLP&lt;/strong&gt;) is a field of &lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_science&quot; title=&quot;Computer science&quot;&gt;computer science&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Artificial_intelligence&quot; title=&quot;Artificial intelligence&quot;&gt;artificial intelligence&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/Linguistics&quot; title=&quot;Linguistics&quot;&gt;linguistics&lt;/a&gt; concerned with the interactions between &lt;a href=&quot;http://en.wikipedia.org/wiki/Computers&quot; title=&quot;Computers&quot;&gt;computers&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Natural_language&quot; title=&quot;Natural language&quot;&gt;human (natural) languages&lt;/a&gt;.”&lt;/p&gt;

&lt;p&gt;So NLP combines a few things — CS, AI, linguistics — but ultimately concerns how computers work with natural languages (aka our human languages). Don’t worry, it doesn’t take a background in CS, AI, or linguistics to get the basics.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Why Do I Care?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I care because NLP has a huge number of potential applications — many of which are challenging, fascinating, and (eventually) world-changing (if computers could actually understand anything — anything — we ask them). But more immediately, I care because NLP is actually tangible and accessible, even for beginners. Much of what I’ve learned in programming is conceptual, or mathematical, or involves a large number of moving pieces. NLP (at its most basic) is taking organized text — a thing I already understand and _can see — _and manipulating and analyzing it in a way that I could talk about with anyone who has read or written text.&lt;/p&gt;

&lt;p&gt;For this (again, really brief) intro, I’m going to use a Python library called &lt;a href=&quot;http://www.nltk.org/&quot;&gt;Natural Language Toolkit&lt;/a&gt; (NLTK). I’ll try to assume as little knowledge as possible, but a basic understanding of how to write Python and interact with the terminal will definitely be helpful. I’m essentially following along with the start of &lt;a href=&quot;http://www.nltk.org/book_1ed/&quot;&gt;this book&lt;/a&gt; (or &lt;a href=&quot;http://www.nltk.org/book/&quot;&gt;this version&lt;/a&gt; if you like Python 3). Just the first section of the &lt;a href=&quot;http://www.nltk.org/book_1ed/ch00.html&quot;&gt;Preface&lt;/a&gt; gave me a much better understanding of why NLP is important and uniquely challenging. It’s written by the creators of NLTK, and gives a much more thorough and understandable intro to using the NLTK library than I ever could. I’ll use two of their intro examples to show what you could do right away.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Getting Set Up&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I’ll assume you already have Python and some kind of interactive terminal (if you have a Mac, both should already be there). If you’re completely new to Python, but are interested in learning about NLP in Python (or in general), the &lt;a href=&quot;http://www.nltk.org/book_1ed/ch01.html&quot;&gt;book I referenced before&lt;/a&gt; does a much better job than I ever could easing a newcomer into both Python and NLP/NLTK.&lt;/p&gt;

&lt;p&gt;In fact, I’ll just point you to &lt;a href=&quot;http://www.nltk.org/book_1ed/ch01.html#getting-started-with-nltk&quot;&gt;this section&lt;/a&gt; for getting set up with NLTK (just those few paragraphs up to ‘Searching Text.’) If you have some experience with &lt;em&gt;pip&lt;/em&gt;** **and/or virtual environments, it can make installing NLTK easier (it’s what I used).&lt;/p&gt;

&lt;p&gt;Once you have your terminal open, here’s what you’ll type:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;$ python&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This should open the Python interactive interpreter (or &lt;a href=&quot;http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop&quot;&gt;REPL&lt;/a&gt;). You can type in Python code and the results of the code will appear immediately. I find it’s a great way to try out my own code, or try using a new library, package, or API, to actually see the results of particular code. I also just love typing some code in and getting immediate feedback. If you have NLTK installed, try  (any text following “&amp;gt;&amp;gt;&amp;gt;” is Python code you can enter):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; from nltk.book import *&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This’ll import a bunch of books! NLTK has a number of text sources — books, news stories, chat logs (anonymized, don’t worry) — to analyze/use in your code. You should see the name of each print as they load. Should look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://78.media.tumblr.com/f9775e12be5531d3e0047e15b97ca968/tumblr_inline_nl1wxuyFjR1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now you can use them!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What Can I Even Do?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Try this:
&lt;img src=&quot;https://78.media.tumblr.com/99432a0edfd859651589fe79287c0bfc/tumblr_inline_nl1wztqZXg1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;_text1 — _the full text of _Moby Dick — _is what you just loaded from NLTK above, and is now accessible/usable by Python. More specifically, it is an object of type ‘Text’ — this is specific to NLTK and allows you to perform a bunch of cool operations on it. In fact, try this:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; dir(text1)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It should look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://78.media.tumblr.com/c3ebf04cb55151980a105519d99be3b1/tumblr_inline_nl1z6aN85R1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;dir()&lt;/em&gt; is a really helpful Python command — it effectively shows all of the attributes associated with the object you put in the parentheses (important to note that everything in Python is an object, so you can use _dir() _with everything — &lt;a href=&quot;http://i.kinja-img.com/gawker-media/image/upload/s--QAu_RHov--/18k2ozi2bcff3jpg.jpg&quot;&gt;even &lt;em&gt;dir()&lt;/em&gt; itself&lt;/a&gt;). Put more simply, it’s everything you can do or access for a given object. It might seem overwhelming, but for now I’ll ignore everything with trailing and/or leading underscores (these are for the most part standard Python operators) and focus on the other stuff, specific to Text objects in NLTK (like ‘collocations’, ‘plot’, and the one we’re about to use).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Searching Text&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Promised we would, so let’s search the text!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; text1.concordance(‘whale’)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://78.media.tumblr.com/b932d3035d2e0fe72d5beb697980f612/tumblr_inline_nl1xm3hQLI1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;concordance _is one of the actions (aka methods) of Text objects (it’s just to. So you have a text object — _text1 — _call a method on it — &lt;/em&gt;.concordance()&lt;em&gt; — and put some argument in the parentheses — &lt;/em&gt;‘whale’&lt;em&gt;. The argument is a string you want to search for in the text. The result of this method is what you see above — all of the places in the text with the word ‘whale’ along with its context (all of the words surrounding it). It’s limited to displaying the top 25 (of 1226 — unsurprisingly, lots of whale talk in _Moby Dick&lt;/em&gt;). This is kind of amazing! It’s probably one of the simplest features of NLTK, but I can imagine a ton of applications — not the least of which is it just looks cool: you could make a web app just to do this and show the context for any word in some text!&lt;/p&gt;

&lt;p&gt;Sidenote: ‘Concordance’ comes from publishing, and refers to exactly what we did above (list words in a text with their contexts). &lt;a href=&quot;http://en.wikipedia.org/wiki/Concordance_%28publishing%29&quot;&gt;Its Wikipedia entry&lt;/a&gt; highlights what makes NLTK, and computing in general, so amazing: ‘Because of the time, difficulty, and expense involved in creating a concordance in the pre-computer era, only works of special importance, such as the Vedas, Bible, Qur’an or the works of Shakespeare or classical Latin and Greek authors, had concordances prepared for them.’ Now we can do it with one command! That’s just the best.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Finding Similar Words&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let’s try another cool method — &lt;em&gt;similar&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;gt;&amp;gt;&amp;gt; text1.similar(‘whale’)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://78.media.tumblr.com/313e0eaf48226eb015a6f44a62d53545/tumblr_inline_nl1zecmrNa1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;According to the NLTK book, &lt;em&gt;similar _finds ‘other words [that] appear in a similar range of contexts’ as the given word. So ‘ship’ is found in more contexts with ‘whale’ than any other word — because of this I can reasonably conclude that the two words are similar in _Moby Dick&lt;/em&gt;. Already I can see how I’d apply this elsewhere — e.g., I could find words similar to a particular topic, which could form the basis for more complex &lt;a href=&quot;http://en.wikipedia.org/wiki/Sentiment_analysis&quot;&gt;sentiment analysis&lt;/a&gt;. Or, again, I could just make a fun web app that allows you to type in a word and get similar words in a body of text. &lt;/p&gt;

&lt;p&gt;This obviously barely scratches the surface of natural language processing and the Natural Language Toolkit, but hopefully gets you a little interested. I’d love to write more about some of the other features/possibilities, and maybe even walk through a project I’ll create with it (though I have to do it first). I’m sure I’ll have more to say soon.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Resources:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nltk.org/book_1ed/&quot;&gt;NLTK book&lt;/a&gt;: The better-written basis for this post. Go try it out!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.nltk.org/&quot;&gt;NLTK&lt;/a&gt;: The home for the Natural Language Toolkit. Has some simple/cool examples and additional resources.&lt;/p&gt;</content><author><name></name></author><summary type="html">Hacker School: Week 10, Day 2</summary></entry><entry><title type="html">Thank the Academy</title><link href="http://jimjshields.github.io/programming,/recurse/center,/oscars/2015/02/19/thank-the-academy.html" rel="alternate" type="text/html" title="Thank the Academy" /><published>2015-02-19T00:00:00-05:00</published><updated>2015-02-19T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/oscars/2015/02/19/thank-the-academy</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/oscars/2015/02/19/thank-the-academy.html">&lt;p&gt;Hacker School: Week 7, Day 4&lt;/p&gt;

&lt;p&gt;Big gap between writing.&lt;/p&gt;

&lt;p&gt;I’ve made pretty steady progress on two projects - one the web framework I’ve been writing, and one a web app (&lt;a href=&quot;http://thanktheacademy.herokuapp.com/&quot;&gt;try it out!&lt;/a&gt;). I’m not really finished either - one of the major problems I’ve noticed in programming is the eternal question I have, “is it finished?” - but the web app is simpler to understand, more fun, and super relevant for the Oscars! (or irrelevant if you don’t like the Oscars).&lt;/p&gt;

&lt;p&gt;Last week, I found &lt;a href=&quot;http://aaspeechesdb.oscars.org/&quot;&gt;this&lt;/a&gt;, a database for Academy Award acceptance speeches. I decided I had to use it. So I first got all of the data together - using Python to gather the data (I’ll leave out the details, but they involve regular expression matching, parsing HTML, and, depressingly, copying and pasting - the site is not the best). And then I built a web app - one with questionable styling, but which does two different, real things!!! - on top of the data! And you can use it!
&lt;img src=&quot;https://78.media.tumblr.com/6bc231220a924fa509aa6dd1bd64cf08/tumblr_inline_nk1eav6wrK1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;First, it &lt;a href=&quot;http://thanktheacademy.herokuapp.com/&quot;&gt;randomly generates an Oscar thank you speech&lt;/a&gt; (like above) based on all speeches ever given. It does this through a concept called a &lt;a href=&quot;http://en.wikipedia.org/wiki/Markov_chain&quot;&gt;Markov chain&lt;/a&gt; - the basic idea is that you take a body of text (here, all speeches) and break it down into sequences of words of a specific number (here, 3 words - but that’s arbitrary) called an &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/N-gram&quot;&gt;n-gram&lt;/a&gt;&lt;/strong&gt;. So a 3-word n-gram could be “Thank you to” or “cast and crew” or “Tommy Lee Jones.” An algorithm (that &lt;a href=&quot;https://github.com/amandapickering/markovgenerator&quot;&gt;another Hacker Schooler wrote&lt;/a&gt; - thanks again!!) then collects every unique n-gram in all of the text, and matches/maps each one to a list of all of the words that follow it. So “Thank you to” would be mapped to “the”, “God”, “my”, and anything else that followed that n-gram in the text. Once that’s done, you can generate a seemingly random block of text - except it’s only random in that it randomly chooses the words based on that previous mapping. So “Thank you to” might be followed by “the”, “God”, or “my” - but never by something it wasn’t mapped to. It’s much more complex than that, and I’m glossing over specifics, but &lt;a href=&quot;http://thanktheacademy.herokuapp.com/&quot;&gt;see it for yourself&lt;/a&gt; - it’ll “randomly” generate a thank you speech for you, one that looks almost real because of the Markov chain being used, and you’ll almost definitely never see the same one twice.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://78.media.tumblr.com/e39857b6600132fb84b39e5d8d063bbd/tumblr_inline_nk1ebeMr521t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Second, I did a &lt;a href=&quot;http://thanktheacademy.herokuapp.com/analysis&quot;&gt;bit of analysis&lt;/a&gt; on the length of the speeches. There are two interactive visualizations - one for the length of every single speech since 1966 (data before that is a bit spotty) and one for the average per year. You can see (above) that, on average, speeches are definitely getting longer, at least by number of words - especially when you include Honorary speeches (those are getting exactly as long as you think - aka REALLY LONG - calm down, D.A. Pennebaker). 
&lt;img src=&quot;https://78.media.tumblr.com/d179c3f86665a12fd7f06c46befa2a98/tumblr_inline_nk1eezhymt1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can also see how long individual speeches are, and filter for particular categories. The one above is Best Picture - if you hover over any of the bars you’ll get all of the associated info - for Titanic. (Shock, they went super long too.) You can even click on “Speech (click to show)” at the bottom to actually see the speech, or be taken directly to the Oscar website entry for that speech (if you’re tryna watch that D.A. Pennebaker speech - hint: it’s so long they don’t even have the full video).&lt;/p&gt;

&lt;p&gt;Overall, this has been a really fun project - but also somewhat frustrating/against what I know is best for my learning. I spent too much time on styling, on data cleaning, on interactivity, and ultimately feel like I could’ve learned more by diving into one particular thing. What’s more, I know this hasn’t been great in that I worked alone on it - Hacker School is especially good as I am surrounded by other programmers, and they’re all willing to work together on really cool projects. I somehow keep finding myself drifting back to working on my own. Ultimately, it makes for projects I want to work on - usually movie-related, clearly - but also leads to me getting lost in my own head, going down rabbit holes, and not focusing on what would be best for learning. I’d like to make a concerted effort in these last few weeks to work with others on projects - even if they’re not exactly what I want to work on.&lt;/p&gt;

&lt;p&gt;Until then, happy Oscars!!!! (if you don’t celebrate, enjoy the weekend, I suppose)&lt;/p&gt;</content><author><name></name></author><summary type="html">Hacker School: Week 7, Day 4</summary></entry><entry><title type="html">Fundamentals</title><link href="http://jimjshields.github.io/programming,/recurse/center,/rotten/tomatoes/2015/02/06/fundamentals.html" rel="alternate" type="text/html" title="Fundamentals" /><published>2015-02-06T00:00:00-05:00</published><updated>2015-02-06T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/rotten/tomatoes/2015/02/06/fundamentals</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/rotten/tomatoes/2015/02/06/fundamentals.html">&lt;p&gt;(Hacker School: Week 5, Day 5. Fair warning, this one's pretty technical.)&lt;/p&gt;
&lt;p&gt;Here I am, it's the fifth day of the fifth week of Hacker School. I haven't written a post in a week - out of laziness, maybe; out of a desire to code instead of write, &lt;a href=&quot;https://www.youtube.com/watch?v=f28klp1qQGI&quot;&gt;oh most definitely&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt;. That's been the value of this week - writing code on my own (as opposed to from tutorials or books).&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;Damn Hard&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;A friend sent me a &lt;a href=&quot;http://www.vikingcodeschool.com/posts/why-learning-to-code-is-so-damn-hard&quot;&gt;great post&lt;/a&gt; the other day that encapsulates much of what has been so strange, and newly frustrating, about learning how to program (mostly) on my own. It's worth a read, especially if you've been learning on your own - you'll just nod your head a lot - but the author's point is that learning to code on your own is hard (damn hard). It's probably not unique in that respect (I can't speak to other disciplines); but, the author speaks well to the particular difficulties I've encountered so far. In the beginning, my learning was certainly characterized by an initial rush of understanding - I know how to write Python! - and a subsequent drop of confidence - I have no idea what to do with Python! It's an empty feeling - I know something, but I don't know what to do with that knowledge. And it began to erode my confidence.&lt;/p&gt;
&lt;p&gt;So in my time off between work and Hacker School, I learned how to build apps/sites in Django and in Meteor - big web frameworks that aren't exactly beginner-friendly. I shot for the moon, and missed, but landed in like, &lt;a href=&quot;http://schmoesknow.com/wp-content/uploads/2014/04/the-17-minute-take-in-gravity-is-a-masterpiece.jpg&quot;&gt;George Clooney territory&lt;/a&gt;, not &lt;a href=&quot;http://www.fbcustom.me/covers/36/1327489921_shoot-for-the-moon.jpg&quot;&gt;among the stars&lt;/a&gt;.&lt;sup&gt;2&lt;/sup&gt; That is, I got something to work! And had no idea how it worked. &lt;/p&gt;
&lt;p&gt;Is that useful - to get something done, have something to show, but not know how it happened? &lt;a href=&quot;https://www.hackerschool.com/manual#sec-principles&quot;&gt;Hacker School doesn't think so&lt;/a&gt; - and I don't either. I think it's much more important to understand something - especially something as complex as a web app - &lt;a href=&quot;http://shieldsofdreams.tumblr.com/post/109617994633/from-the-ground-up&quot;&gt;from the ground up&lt;/a&gt;.&lt;sup&gt;3&lt;/sup&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;The Fundamentals&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;And that's what I've been focusing on here - learning why and how something works. But it's time-consuming, often confusing, and there's not always something visible to show for it. So this week has been especially interesting in being mostly spent on two very different projects.&lt;/p&gt;
&lt;p&gt;The first project is a small web framework, written in Python. I've been working alongside a fellow Hacker Schooler, Paul, and we've been building similar but separate frameworks. We spent much of the week digging as deeply as possible into how to build a web application in Python from scratch. And we've learned a lot - about how the internet works, how and why simple web frameworks (like &lt;a href=&quot;http://bottlepy.org/docs/dev/index.html&quot;&gt;Bottle&lt;/a&gt; and &lt;a href=&quot;http://flask.pocoo.org/docs/0.10/&quot;&gt;Flask&lt;/a&gt;) do what they do, and how to handle seemingly simple things like HTTP requests. It's fascinating, fun, and often frustrating to build something from scratch - it's helped me to appreciate the people who have spent their time making sure 99.5% of us never have to think about things like HTTP requests or URLs. But at the same time, here's my visible progress thus far:&lt;/p&gt;
&lt;hr /&gt;
&lt;figure&gt;&lt;img src=&quot;https://78.media.tumblr.com/2385cf10cb87e7c73fb8bb79ebd8178d/tumblr_inline_njd1dyPylz1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;But is visible progress even important? Would I learn more if I actually built something - something that does more than allows me to type in my name and favorite movie and shows a lame, code-esque representation of exactly what I typed in?&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;Overcoming 'Fear'&lt;sup&gt;5&lt;/sup&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;My second project came to me late Wednesday afternoon. I've been wanting to use the &lt;a href=&quot;http://developer.rottentomatoes.com/&quot;&gt;Rotten Tomatoes API&lt;/a&gt; - Rotten Tomatoes is a movie review aggregation site, so naturally I wanted to use it - but had been legitimately scared off because I couldn't conceptualize how it would work. Most simply, I was scared of the word (acronym) &lt;a href=&quot;http://en.wikipedia.org/wiki/Application_programming_interface&quot;&gt;API&lt;/a&gt;. Programmers around me have used 'API' to describe so many seemingly unrelated things that it became almost impossible for me to wrap my head around what it meant concretely. But in &lt;a href=&quot;https://www.hackerschool.com/manual#sub-sec-fear&quot;&gt;keeping with the spirit of Hacker School&lt;/a&gt;, I was determined to confront that fear. Here's a great passage from HS's manual (linked above):&lt;/p&gt;
&lt;blockquote&gt;&lt;div&gt;Another obstacle we try to remove is fear. We think this is one of the most pernicious impediments to education. In most of the world, but especially school and work, people are afraid of looking stupid. This fear frequently keeps us from asking important questions like &quot;how does that work?&quot; or even just &quot;why?&quot; Worse, it keeps us from saying &quot;I don't understand.&quot; That means many of us muddle on with a half-baked or entirely incorrect understanding of core concepts. This is particularly bad with programming, because these misunderstandings compound, and over time become harder and more embarrassing to admit to and address.&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;So I pressed forward to find out how it worked. And as it turned out, there was nothing to be scared of - it entirely depends on the API, but the one given by Rotten Tomatoes is easy to use if you have some understanding of URLs and working with JSON data (if you don't, that's ok too! It takes some time to learn but is at least pretty intuitive). The basic concept is you, as a developer, get a key from them - this tells them you're not a robot, essentially - and then you can access a certain amount of data in a predefined format (JSON) using predefined queries/parameters - like a movie you want to search for, or a specific data set like upcoming movies (in the form of URLs). And then you can do what you want with that data. So here's what I did!&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;&lt;img src=&quot;https://78.media.tumblr.com/f9d87f016125ee80b1552ca024b124de/tumblr_inline_njdafwSflU1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;I made a command line interface! It's not done yet - you can't actually access all of those things (well, &lt;i&gt;you&lt;/i&gt; can't access any of them yet, only I can) - but I've made good progress. It's less cool-looking than a fully-functional web app - but also a lot easier to make, and thus a lot less frustrating. It was an easy win for me, got me motivated about building something on my own, and was fun to do - all a great contrast to something more esoteric like building a web framework.&lt;/p&gt;

&lt;p&gt;More importantly, let's search for a movie - 'batman'!!!&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;&lt;img src=&quot;https://78.media.tumblr.com/c69d8cd8c78feb836d70667fc3e8f396/tumblr_inline_njdami8MIH1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;I don't care about &lt;i&gt;The Dark Knight&lt;/i&gt;&lt;sup&gt;6&lt;/sup&gt; - let's get more info on &lt;i&gt;Batman &amp;amp; Robin&lt;/i&gt;!&lt;/p&gt;
&lt;figure class=&quot;&quot;&gt;&lt;img src=&quot;https://78.media.tumblr.com/c68f96110a3eeb9a9d67b98cd393d0c3/tumblr_inline_njdao9r2Mm1t8beow.png&quot; alt=&quot;image&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;So 'more info' just means small snippets of reviews for now - but it's something. And hey, you can easily see who hated and loved Batman &amp;amp; Robin! (Answer: everyone hated it except the Times, inexplicably. And 'wounded yeti' could stand to be part of the lexicon over, like, selfie.)&lt;/p&gt;
&lt;p&gt;In conclusion: it's a valuable struggle to build something from scratch - I for one have learned a lot so far from the experience of building a web framework. At the same time, I'd argue that it's extremely important when learning any skill - but especially something as broad and potentially overwhelming as programming - to work on small, doable, motivating projects applying some small portion of what's been learned so far. These allow for a mental breather - I don't have to learn a whole new concept - and help to actually solidify learning in a meaningful, lasting way. It was rejuvenating to build something quickly, easily, and with showable results - and in color! What a week.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;sup&gt;1. If by some unfortunate accident you haven't watched &lt;i&gt;Arrested Development&lt;/i&gt; do yourself a favor and stop reading this right now, come back in 25 hours when you're done, thanks.&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;2. I really wanted to clumsily work that overly inspirational quote in there somehow. &lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;3. Bold move, plugging your own blog in your blog.&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;4. No, I didn't watch &lt;i&gt;The Social Network&lt;/i&gt; and get really inspired to go and learn programming. The Zuck of that movie is lonely and sad and &lt;i&gt;Citizen-Kane&lt;/i&gt;-esque and I don't want to emulate it. It's just a great movie by a great director who can't stop making great movies. (And I just like programming.)&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;5. Not &lt;a href=&quot;http://www.imdb.com/title/tt0116287/&quot;&gt;this Fear.&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;6. Lie.&lt;/sup&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 5, Day 5. Fair warning, this one's pretty technical.) Here I am, it's the fifth day of the fifth week of Hacker School. I haven't written a post in a week - out of laziness, maybe; out of a desire to code instead of write, oh most definitely1. That's been the value of this week - writing code on my own (as opposed to from tutorials or books). Damn Hard A friend sent me a great post the other day that encapsulates much of what has been so strange, and newly frustrating, about learning how to program (mostly) on my own. It's worth a read, especially if you've been learning on your own - you'll just nod your head a lot - but the author's point is that learning to code on your own is hard (damn hard). It's probably not unique in that respect (I can't speak to other disciplines); but, the author speaks well to the particular difficulties I've encountered so far. In the beginning, my learning was certainly characterized by an initial rush of understanding - I know how to write Python! - and a subsequent drop of confidence - I have no idea what to do with Python! It's an empty feeling - I know something, but I don't know what to do with that knowledge. And it began to erode my confidence. So in my time off between work and Hacker School, I learned how to build apps/sites in Django and in Meteor - big web frameworks that aren't exactly beginner-friendly. I shot for the moon, and missed, but landed in like, George Clooney territory, not among the stars.2 That is, I got something to work! And had no idea how it worked.  Is that useful - to get something done, have something to show, but not know how it happened? Hacker School doesn't think so - and I don't either. I think it's much more important to understand something - especially something as complex as a web app - from the ground up.3 The Fundamentals And that's what I've been focusing on here - learning why and how something works. But it's time-consuming, often confusing, and there's not always something visible to show for it. So this week has been especially interesting in being mostly spent on two very different projects. The first project is a small web framework, written in Python. I've been working alongside a fellow Hacker Schooler, Paul, and we've been building similar but separate frameworks. We spent much of the week digging as deeply as possible into how to build a web application in Python from scratch. And we've learned a lot - about how the internet works, how and why simple web frameworks (like Bottle and Flask) do what they do, and how to handle seemingly simple things like HTTP requests. It's fascinating, fun, and often frustrating to build something from scratch - it's helped me to appreciate the people who have spent their time making sure 99.5% of us never have to think about things like HTTP requests or URLs. But at the same time, here's my visible progress thus far: 4 But is visible progress even important? Would I learn more if I actually built something - something that does more than allows me to type in my name and favorite movie and shows a lame, code-esque representation of exactly what I typed in? Overcoming 'Fear'5 My second project came to me late Wednesday afternoon. I've been wanting to use the Rotten Tomatoes API - Rotten Tomatoes is a movie review aggregation site, so naturally I wanted to use it - but had been legitimately scared off because I couldn't conceptualize how it would work. Most simply, I was scared of the word (acronym) API. Programmers around me have used 'API' to describe so many seemingly unrelated things that it became almost impossible for me to wrap my head around what it meant concretely. But in keeping with the spirit of Hacker School, I was determined to confront that fear. Here's a great passage from HS's manual (linked above): Another obstacle we try to remove is fear. We think this is one of the most pernicious impediments to education. In most of the world, but especially school and work, people are afraid of looking stupid. This fear frequently keeps us from asking important questions like &quot;how does that work?&quot; or even just &quot;why?&quot; Worse, it keeps us from saying &quot;I don't understand.&quot; That means many of us muddle on with a half-baked or entirely incorrect understanding of core concepts. This is particularly bad with programming, because these misunderstandings compound, and over time become harder and more embarrassing to admit to and address. So I pressed forward to find out how it worked. And as it turned out, there was nothing to be scared of - it entirely depends on the API, but the one given by Rotten Tomatoes is easy to use if you have some understanding of URLs and working with JSON data (if you don't, that's ok too! It takes some time to learn but is at least pretty intuitive). The basic concept is you, as a developer, get a key from them - this tells them you're not a robot, essentially - and then you can access a certain amount of data in a predefined format (JSON) using predefined queries/parameters - like a movie you want to search for, or a specific data set like upcoming movies (in the form of URLs). And then you can do what you want with that data. So here's what I did! I made a command line interface! It's not done yet - you can't actually access all of those things (well, you can't access any of them yet, only I can) - but I've made good progress. It's less cool-looking than a fully-functional web app - but also a lot easier to make, and thus a lot less frustrating. It was an easy win for me, got me motivated about building something on my own, and was fun to do - all a great contrast to something more esoteric like building a web framework.</summary></entry><entry><title type="html">From the Ground Up</title><link href="http://jimjshields.github.io/programming,/recurse/center,/learning,/make/it/stick,/deliberate/practice/2015/01/30/from-the-ground-up.html" rel="alternate" type="text/html" title="From the Ground Up" /><published>2015-01-30T00:00:00-05:00</published><updated>2015-01-30T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/learning,/make/it/stick,/deliberate/practice/2015/01/30/from-the-ground-up</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/learning,/make/it/stick,/deliberate/practice/2015/01/30/from-the-ground-up.html">&lt;p&gt;(Hacker School: Week 4, Day 5)&lt;/p&gt;

&lt;p&gt;Like I said at the beginning of the week, it’s really hard to write something every day. It’s been most difficult this week, when I’ve felt like I’ve made steady progress, but have very little to tangibly show for it.&lt;/p&gt;

&lt;p&gt;Though it’s more difficult to put into words or show an example, this week has been especially good for two things: deliberate practice and understanding a topic from the ground up.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Practice_(learning_method)#Deliberate_practice&quot;&gt;Deliberate practice&lt;/a&gt; is the idea - introduced by a group of researchers ~20 years ago, and since popularized in a bunch of books (&lt;em&gt;Outliers&lt;/em&gt;, mainly, but also in &lt;em&gt;Make It Stick&lt;/em&gt;) - that those who become experts in a particular area do so less because of innate ability and more due to their specifically-structured practice over a long period of time (that’s the 10,000 hour rule). Generally, it takes the form of picking a specific part of a topic a bit beyond one’s reach - but building upon previous experience - practicing that part, getting targeted feedback on one’s performance, and repeating the process, over and over. It’s a step-by-step process - each thing one practices builds upon the last and strengthens overall skill in the area (so the theory goes). &lt;a href=&quot;http://www.sciencedirect.com/science/article/pii/S0160289613000421&quot;&gt;Though there’s some dissent&lt;/a&gt; with the idea that it explains expert performance, I still think it can be applied advantageously to my own learning. I’m not an expert in programming by any means - not even close, and may never be - but reflecting upon what I’ve learned, looking ahead and structuring my next step to be a bit harder than the last, and practicing until I’ve fully grasped that topic, has been more valuable to my progress than anything so far. It just wasn’t until reading &lt;em&gt;Make It Stick&lt;/em&gt; (and &lt;a href=&quot;http://jamesclear.com/deliberate-practice-strategy&quot;&gt;at least one blog post&lt;/a&gt;) that I put a name to it.&lt;/p&gt;

&lt;p&gt;That directly relates to the other part - understanding something from the ground up. Though I like knowing the big picture - i.e., can be &lt;a href=&quot;http://www4.ncsu.edu/unity/lockers/users/f/felder/public/ILSdir/styles.htm&quot;&gt;a global learner&lt;/a&gt; (as Mel Chua highlighted to us in our first week here) - day-to-day I’m usually much more concerned with learning something step by step - i.e., sequentially. I get easily frustrated if I’m going through a tutorial or book or class and realize there are 25 things that the author or professor assumes I already know. This single thing - the assumption of knowledge, and the overwhelming amount of assumed knowledge - has been my biggest frustration in learning programming and computer science. With a few exceptions, nearly everyone with information about a particular topic (usually, authors of books and tutorials) assumes you come in knowing a, b, and c (and usually d-z and 1-10). (Granted, much of the learning resources are free - and anyway, every single author can’t be expected to hold your hand through their topic.)&lt;/p&gt;

&lt;p&gt;My lack of knowledge often comes from the obvious place - not having a computer science degree - but it doesn’t come from a lack of curiosity. I want to learn these things! It just takes so much time! If I want to build an app, do I really need to learn how the language works, how databases work, what routing is, what HTTP requests are, how to authenticate users, how to keep it secure, how to interact with the front end, how to deploy it to Heroku or Amazon so everyone can actually see it? Hacker School would - I think, rightly - argue that yes, it is more important that I understand fundamentally how each piece works before building something. Do I need to know every single thing in minute detail? Definitely not. But I will be a better programmer - and ultimately a better learner - if I take the time, and yes, the frustration, to learn the fundamentals and build from there.&lt;/p&gt;

&lt;p&gt;So to bring it back to deliberate practice, this week I structured my time around starting from the ground up in developing a web app in Python. Doing this ensured I stepped from one level to the next, more or less sequentially - it’s also much easier to grasp what I don’t know when starting at the very bottom. I learned how to build an app without a framework (it’s using something called WSGI - likely a topic for a future post). Then I started to learn why frameworks exist, and why each small piece was added. This was a slow but ultimately rewarding process - by the end of the week I felt much more comfortable using something like Flask - one of the Python web frameworks I’ve mentioned before - to build an app, than I did before. And I did it by identifying things I didn’t yet know, practicing them, and then moving onto the next thing.&lt;/p&gt;

&lt;p&gt;I still feel like I didn’t do much this week, but I suspect I’ll be grateful for the foundation I’ve been building. Hopefully I can remember everything I had to learn - the other most difficult thing about learning is knowing &lt;strong&gt;what&lt;/strong&gt; to learn next, and the best resource to do it. I’d love a trusted source for sequential learning of particular programming topics or concepts. (There are great ones for CS topics - &lt;a href=&quot;https://www.coursera.org/&quot;&gt;Coursera&lt;/a&gt; has a bunch of great (&lt;strong&gt;FREE!!!!&lt;/strong&gt;) courses from top schools - I’m currently moving between &lt;a href=&quot;https://class.coursera.org/algs4partI-007/lecture&quot;&gt;three&lt;/a&gt; &lt;a href=&quot;https://www.coursera.org/course/algo&quot;&gt;different&lt;/a&gt; &lt;a href=&quot;http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00sc-introduction-to-computer-science-and-programming-spring-2011/index.htm&quot;&gt;Intro&lt;/a&gt; courses - the other major frustration is how difficult CS can be to start understanding.)&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 4, Day 5)</summary></entry><entry><title type="html">Some Things I Learned in Week 3 at Hacker School</title><link href="http://jimjshields.github.io/programming,/recurse/center,/learning/2015/01/26/some-things-i-learned-in-week-3-at-hs.html" rel="alternate" type="text/html" title="Some Things I Learned in Week 3 at Hacker School" /><published>2015-01-26T00:00:00-05:00</published><updated>2015-01-26T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/learning/2015/01/26/some-things-i-learned-in-week-3-at-hs</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/learning/2015/01/26/some-things-i-learned-in-week-3-at-hs.html">&lt;p&gt;(Hacker School: Week 4, Day 1)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It’s unexpectedly difficult to write a blog post every single day. So, while I’ll try to, it’s naive of me to think I can do that before/after spending all day learning.&lt;/li&gt;
  &lt;li&gt;It’s hard enough to focus in a directed environment like college or a job; it’s that much harder to do it in a completely undirected environment. It takes a lot of willpower to direct my attention toward only a few things in a given day or week and shift my attention away from a million other interesting things.&lt;/li&gt;
  &lt;li&gt;Because of that effort, I know I’ll gradually improve at focusing in this environment, which will only be more helpful in a more directed environment.&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;Programming is a complex and involved discipline. When I started learning over a year ago, I definitely did not have enough respect for how much I’d need to learn and how difficult it is. Learning a language is only a tiny piece (and likely the most straightforward) of becoming a programmer, and I know I still have a while to go.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Recursion&quot;&gt;Recursion&lt;/a&gt; is an inherently confusing concept, and even when I thought I understood it (at many points in the last year), I realized I really didn’t. Last week brought me a little closer.&lt;/li&gt;
  &lt;li&gt;Hacker School has presentations every Thursday where they encourage anyone and everyone to present whatever it is they’re working on or interested in, in any state of completion. It really feels great, and motivating, to present something to a group of people who aren’t primed to judge you or your project. It’s also much easier for someone like me who is usually nervous to show anyone any of my work - because I’d be afraid they’d think it was simple, or bad, or uninteresting. That’s a silly way for me to think - if anyone would be so judgmental about my creating something, however simple, bad, or uninteresting, they’re probably not worth my time anyway.&lt;/li&gt;
  &lt;li&gt;When programming (but I think when doing anything), while it feels good and productive to build something - to display visible progress - it feels equally good, if not better, to go back and refine it, to fix any issues and shore up the foundation, to make it smaller, less complex, and ultimately better grounding on which to build more. I did this with the project I presented - I refactored the code&lt;sup&gt;2&lt;/sup&gt;, made indentation and variable names consistent, and added comments to clarify anything that’s confusing about my code. It sounds boring; it felt great.&lt;/li&gt;
  &lt;li&gt;Reading about not-directly-relevant things often helps me to understand more about what I’m focusing most of my energy on. I talked a little in other posts about _Make It Stick - _which I’d definitely recommend, especially if you’re interested in learning itself - it helped me to structure my time and energy here in a way that engenders better, more lasting learning. And it helped me to be more comfortable with getting frustrated, and feeling lost and incompetent. After I finished that, I started _&lt;a href=&quot;http://www.amazon.com/Quiet-Power-Introverts-World-Talking-ebook/dp/B004J4WNL2&quot;&gt;Quiet&lt;/a&gt; - _a similarly structured book (drawing on equal parts empirical research, anecdotes, and history to make a larger point about the topic) - and it’s already helped me to view my introversion and desire to work on my own or spend time thinking about things in a more positive light. Neither have a single thing to say about programming (yet) but both have already supported my time here in a very positive way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And now I begin my work for the week - which will be completely destroyed by the &lt;a href=&quot;http://www.weather.com/storms/winter/news/winter-storm-juno-blizzard-boston-nyc-new-england&quot;&gt;STORM OF THE CENTURY&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;sup&gt;1 This is related to what that book, &lt;em&gt;Make it Stick&lt;/em&gt;, had to say about learning - it’s only going to stick when it’s effortful. I think that’s generalizable to other things - like focusing. If it’s hard now, and I struggle through it, it’ll be easier later, especially in a more structured environment.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;2 Pretty much exactly that - refined it, made it smaller, simpler, easier to understand what’s going on.&lt;/sup&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 4, Day 1)</summary></entry><entry><title type="html">Slow Progress</title><link href="http://jimjshields.github.io/programming,/recurse/center,/flask,/algorithms/2015/01/21/slow-progress.html" rel="alternate" type="text/html" title="Slow Progress" /><published>2015-01-21T00:00:00-05:00</published><updated>2015-01-21T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/flask,/algorithms/2015/01/21/slow-progress</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/flask,/algorithms/2015/01/21/slow-progress.html">&lt;p&gt;(Hacker School: Week 3, Day 3)&lt;/p&gt;

&lt;p&gt;This is a quick post about today and yesterday - not on any particular topic, and more on my own sluggish and sometimes frustrating progress. This one’s definitely HS-specific.&lt;/p&gt;

&lt;p&gt;I spent much of yesterday following a &lt;a href=&quot;http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world&quot;&gt;fairly involved tutorial in Flask&lt;/a&gt; - but only got through the first five pieces. As has often been true for me lately (and seems to be true of any programming/CS topic), learning something really means learning 25 things - and I never know upfront how much I don’t know.&lt;/p&gt;

&lt;p&gt;The rest of the day, and some of today, I started a (very free!!) online course (aka &lt;a href=&quot;http://en.wikipedia.org/wiki/Massive_open_online_course&quot;&gt;MOOC&lt;/a&gt;) in Algorithms from Stanford. I find that the concepts are complex, but I can wrap my mind around them - but struggle with translating them into code. I’m lucky that I have the time and energy to struggle through problems - and hopefully in that way making them stick (tm) - but I find that process a bit disheartening sometimes. It’s a similar struggle, between spending a ton of time understanding every detail and being comfortable moving on from something if it isn’t important.&lt;/p&gt;

&lt;p&gt;Finally, today I picked up my own project that I’d been working on prior to starting here. I essentially took all of the available data from the &lt;a href=&quot;http://www.imdb.com/chart/top&quot;&gt;IMDb Top 250&lt;/a&gt; - a publicly-voted list of the best films of all time (HIGHLY subjective - and often biased) - since it began in 1996. I’ll leave out the specifics of how I did that for now, but I think that could be a later post. I then translated it into an interactive visualization - one where you can easily digest how the public’s feelings (through a pretty big and untrustworthy, but best available, proxy) on particular movies have changed over time. I was able to port all of the data I have from Excel/csv to a real database, and got it to display the visualization - but it’s over 800,000 rows of data, so it’s extremely slow. Hoping to come up with a way to speed it up and make it usable, because I think it’ll be pretty cool.&lt;/p&gt;

&lt;p&gt;The best parts of the past two days have been working with others - though I’ve often approached it less positively than I should, because I have so much I want to work on by myself. When I can come to terms with the idea that I’ll never finish everything I want, and that I always learn more from working with others than on my own, I’ll be a bit more comfortable. But I sat in two really interesting sessions - one by Mary, one of the facilitators here at HS, about the inner workings of Git (it helped in thinking about the seemingly impossible-to-penetrate way that Git actually works); and one in which a group of us met to talk about the Algorithms course so far. Both were enlightening and made me feel less frustrated and stuck in my own progress; I hope to keep working in those kinds of sessions.&lt;/p&gt;

&lt;p&gt;More tomorrow.&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 3, Day 3)</summary></entry><entry><title type="html">Some Resources for Flask</title><link href="http://jimjshields.github.io/programming,/recurse/center,/flask,/python/2015/01/20/some-resources-for-flask.html" rel="alternate" type="text/html" title="Some Resources for Flask" /><published>2015-01-20T00:00:00-05:00</published><updated>2015-01-20T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/flask,/python/2015/01/20/some-resources-for-flask</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/flask,/python/2015/01/20/some-resources-for-flask.html">&lt;p&gt;(Hacker School: Week 3, Day 1)&lt;/p&gt;

&lt;p&gt;Wasn’t technically at HS yesterday, but I wanted to give a little more detail on how I learned Flask last week. This is really only interesting if you want to work with Flask, so I guess you’ve been warned.&lt;/p&gt;

&lt;p&gt;Here are my major takeaways from learning Flask:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It’s a web framework written in and for Python.&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;It’s relatively easy to learn - but that’s relative to larger frameworks like Django (for Python) or Rails (for Ruby). If you’re truly new to web development, there’s still a good amount of assumed knowledge/understanding.&lt;/li&gt;
  &lt;li&gt;It’s easy to learn because it does only a few, specific things, and those things don’t take too long or too much pre-requisite knowledge to understand.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are some great resources for getting started, though they do require a minimal amount of assumed knowledge of intermediate topics in Python, the underlying concepts of web applications (routing, templating, HTTP requests, etc.), and working with databases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/docs/0.10/&quot;&gt;Official Flask documentation&lt;/a&gt;: Great if you have some experience in other frameworks/have developed web apps on your own before.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/docs/0.10/quickstart/&quot;&gt;Quickstart&lt;/a&gt; (also part of the official Flask docs): Perfect if you just want to get something working, even if you’re just starting out. Does assume you’ve installed it already, which is outlined by them &lt;a href=&quot;http://flask.pocoo.org/docs/0.10/installation/&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/docs/0.10/tutorial/&quot;&gt;Tutorial&lt;/a&gt; (again, official): A little more advanced - they take you step-by-step through building a web app using a database and some templates. More assumed knowledge here, so a bit more confusing if you’re just starting out.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world&quot;&gt;The Flask Mega-Tutorial&lt;/a&gt;: Written by Miguel Grinberg, who wrote the &lt;a href=&quot;http://flaskbook.com/&quot;&gt;O’Reilly book on Flask&lt;/a&gt;&lt;sup&gt;2&lt;/sup&gt;, a more in-depth tutorial that spends more time getting you oriented, even if you’re just getting started. If you have some more time and patience to get into the details and possibilities of using Flask, this is a thorough but straightforward intro.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jinja.pocoo.org/docs/dev/&quot;&gt;Jinja2 documentation&lt;/a&gt;: One of the two&lt;sup&gt;3&lt;/sup&gt; pre-installed libraries for Flask is called Jinja2. It allows you to use templating to build dynamic HTML templates that will render using data derived from databases and manipulated using Python. Once you have an understanding of how it works, it’s powerful - but until then it can be a little confusing. &lt;a href=&quot;http://jinja.pocoo.org/docs/dev/intro/#basic-api-usage&quot;&gt;Here’s a simple example.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/docs/0.10/patterns/sqlite3/#sqlite3&quot;&gt;Using SQLite3 with Flask&lt;/a&gt; (again, part of the offish docs): assumes that you know basic SQL and how to work with databases. If you’re not familiar, it’s worth struggling through this part on your own - and especially trying to understand what each piece of code does. Hopefully I’ll write a more detailed post soon that walks through that; it’s just a broad and potentially complex topic.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bev-a-tron/MyFlaskTutorial&quot;&gt;My Flask Tutorial&lt;/a&gt;: A former HSer (bev-a-tron on GitHub) wrote what looks to be (and recommended by multiple HSers as) an excellent intro to Flask for people who don’t have all of the knowledge the above tutorials tend to assume. I haven’t worked through it yet but even the intro makes it clear that the tutorial is truly a tutorial - for people with no web development experience (just some Python experience).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’m sure there are other good resources - I’ll try to add them here if I encounter them - but these are great for just getting started in Flask. A lot of the concepts introduced in Flask also translate easily to other web frameworks - and it’s worth knowing what the framework actually does for you, in case you can’t rely on it for some reason (e.g., it doesn’t do what you want it to).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;sup&gt;1. Obvious, yes. But if you don’t know what that means, you probably won’t be interested in the rest of this. But if you are interested, and you don’t know what that means, you just have to learn a bit more - and that’s ok too! Or you might just want to struggle through learning this - it’ll make it stick, so to speak.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;2. &lt;a href=&quot;http://www.oreilly.com/&quot;&gt;O’Reilly&lt;/a&gt; is a terrific - and pretty much the definitive - resource for books on programming. I’ve read a few, and they tend to be easy to read, step-by-step, and comprehensive. (Also, many are free online!)&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;3. There’s another - &lt;a href=&quot;http://werkzeug.pocoo.org/docs/0.9/&quot;&gt;Werkzeug&lt;/a&gt; - that takes care of WSGI/HTTP stuff for Flask. I haven’t learned much of it yet - I just know that it allows you not to deal with the lower-level details necessary for building a web app in Python. They also have &lt;a href=&quot;http://werkzeug.pocoo.org/docs/0.9/tutorial/&quot;&gt;a tutorial&lt;/a&gt; - I haven’t worked through it but it seems detailed and actually kinda fun.&lt;/sup&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 3, Day 1)</summary></entry><entry><title type="html">Some Things I Learned in Week 2 at Hacker School</title><link href="http://jimjshields.github.io/programming,/recurse/center,/learning,/make/it/stick/2015/01/16/some-things-i-learned-in-week-2-at-hs.html" rel="alternate" type="text/html" title="Some Things I Learned in Week 2 at Hacker School" /><published>2015-01-16T00:00:00-05:00</published><updated>2015-01-16T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/learning,/make/it/stick/2015/01/16/some-things-i-learned-in-week-2-at-hs</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/learning,/make/it/stick/2015/01/16/some-things-i-learned-in-week-2-at-hs.html">&lt;p&gt;(Hacker School: Week 2, Day 4)&lt;/p&gt;

&lt;p&gt;Out of laziness/inability to put together a coherent and thoughtful summation of my week, I’ll stick to the random list format. (h/t &lt;a href=&quot;http://www.buzzfeed.com/&quot;&gt;randomlists.com&lt;/a&gt;)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What a web framework does. Using Flask as a proxy for understanding the larger point of web frameworks was a good choice - I’d recommend it to anyone looking to start learning web development. It takes a bit of effort to connect the underlying concepts to what Flask does specifically, but it is a good starting point. I’d like to elaborate more in a (more coherent and thoughtful) post on what exactly it does, how to use it to make something simple, and what’s difficult about using it for someone unfamiliar with programming or web frameworks.&lt;/li&gt;
  &lt;li&gt;How to work with a database in the simplest possible way. I had a decent grasp of how to write SQL queries - basically, what you write to get, add, or update data in a database - but had very little understanding of how to set one up, make it work with a web app, or even what one really is. Again, a later, better post.&lt;/li&gt;
  &lt;li&gt;What actually happens when you visit a website on your browser.&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;It’s not a good idea to install whatever you want at any time. This is probably good advice in general - but especially for a programmer. In Python, it’s considered bad practice to install all but very few packages globally&lt;sup&gt;2&lt;/sup&gt;. Instead, you should create - and consistently use - &lt;a href=&quot;https://virtualenv.pypa.io/en/latest/&quot;&gt;virtual environments&lt;/a&gt;. This is something that always gave me some confusion/fear - the name “virtual environment” in and of itself is not super helpful in understanding what it does - but they basically allow you to install sets of packages specific to a particular project, without having them conflict across projects. Again, a whole blog post.&lt;/li&gt;
  &lt;li&gt;User authentication is still confusing; I’ll return to it later.&lt;sup&gt;3&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;It’s a good idea to stick to the specifications (aka specs, a good fancy tech word) you set out for yourself when building a program - no matter how small. You can return to and refine those specs at any time, but without a map, you can easily get lost. Don’t be me when coming out of a subway station - orient yourself before just walking in the direction that seems kinda-sorta-yeah-it-must-be-north, and then walk south for like ten minutes, especially in an unfamiliar setting.&lt;sup&gt;4&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;Regular expressions! They are scary and potentially confusing and I’d avoided them for a while. But they are also super cool - and there’s a great step-by-step, interactive tutorial for them &lt;a href=&quot;http://regexone.com/&quot;&gt;here&lt;/a&gt;.&lt;sup&gt;5&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;How to learn, and how to reflect on how I learn. Already plugged this book, but &lt;a href=&quot;http://www.amazon.com/Make-It-Stick-Successful-Learning/dp/0674729013&quot;&gt;Make It Stick&lt;/a&gt; is really insightful on this topic - though I’m surprised by how common-sensical the author’s arguments seem. For example - it’s a good idea to weave (or their word, interleave) different topics together over the course of learning a larger topic - rather than the typical chunks of information (like a math textbook, where you learn one topic completely, then move onto the next and forget about the last one). It makes so much sense! I definitely don’t learn this way, so I’d like to refine my learning habits to be more in line with what they recommend during my time here.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’m sure I learned a million other things, but these have stuck with me this week. Looking forward to learning more, and more deeply, next week.&lt;sup&gt;6&lt;/sup&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;sup&gt;1 You type in a URL - that’s a request - the website’s server sends back data that’s been formatted in HTML - that’s the response - and the browser renders it/makes it look like a website. Or you don’t - that’s your prerogative.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;2 Packages - basically programs written for use with Python (and other programming languages; in some other languages they’re called something different). Installing globally - installing in your main/root directory so that you can access those programs at any time with any program you write.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;3 Is this a cheating one? Kind of, but I learned that it is still confusing, so that’s something!&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;4 And especially especially outside of the confines of the Manhattan-above-Union-Square grid (or your city’s/town’s equivalent).&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;5 If you don’t know what a regular expression is - it’s essentially a way to search for patterns in text, &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;used in computer science but also in formal language theory&lt;/a&gt; (not my words). For example, you want to find all words that have three a’s - no more, no less - you can use the regular expression &lt;em&gt;a{3}&lt;/em&gt; (I think, would be embarrassing if I have that wrong).&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;6 …on Serial.&lt;/sup&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 2, Day 4)</summary></entry><entry><title type="html">Making It Stick</title><link href="http://jimjshields.github.io/programming,/recurse/center/2015/01/15/making-it-stick.html" rel="alternate" type="text/html" title="Making It Stick" /><published>2015-01-15T00:00:00-05:00</published><updated>2015-01-15T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center/2015/01/15/making-it-stick</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center/2015/01/15/making-it-stick.html">&lt;p&gt;(Hacker School: Week 2, Day 3)&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;If Tuesday was frustrating in the lack of traditional or measurable productivity, yesterday was gratifying in actually completing defined steps of a project. But the question is, did I actually learn anything?&lt;/p&gt;

&lt;p&gt;After my post yesterday, a few gracious Hacker Schoolers (HSers, for brevity’s sake) wholeheartedly recommended the book &lt;a href=&quot;http://www.amazon.com/Make-It-Stick-Successful-Learning/dp/0674729013&quot;&gt;Make It Stick&lt;/a&gt; as a way to think about how I learn, and potentially more effective ways of learning than the traditionally understood techniques. I was convinced&lt;sup&gt;2&lt;/sup&gt; and got the eBook&lt;sup&gt;3&lt;/sup&gt; and started reading. In the first few pages&lt;sup&gt;4&lt;/sup&gt;, the authors summarize their primary arguments - I’ll highlight two (especially relevant) quotes here:&lt;/p&gt;

&lt;p&gt;“Rereading and massed practice give rise to feelings of fluency that are taken to be signs of mastery, but for true mastery or durability these strategies are largely a waste of time.”&lt;/p&gt;

&lt;p&gt;“Learning is deeper and more durable when it’s &lt;em&gt;effortful&lt;/em&gt;. Learning that’s easy is like writing in sand, here today and gone tomorrow.”&lt;/p&gt;

&lt;p&gt;The first quote effectively captures my first few days here at HS. If you’ve read my first few posts&lt;sup&gt;5&lt;/sup&gt;, you might be thinking to yourself, “hm, that sure sounds like the authors of this book are describing Jim’s first few days at HS as a quote unquote waste of time.” And it had the potential to be a waste of time. But last week, I also pair programmed on a small Python project, and in doing that had a - wait for it - effortful experience putting the concepts I’d read about and practiced into action in an unfamiliar situation (another technique the authors advocate). So I learned!&lt;/p&gt;

&lt;p&gt;This week, I spent much of the first few days reading the documentation of Flask - a Python web framework that allows you to build small apps - and working through some Flask tutorials. And I felt like I didn’t really learn anything. I’d read a lot - and practiced a lot - but it felt like nothing truly stuck. But yesterday, I put what I’d learned into action in an unfamiliar situation - a web app that tracks my to-do list on a daily basis. It’s a simple concept, but it seriously solidified my learning - not only did I have to understand the specifics of Flask, but also had to generalize that learning to the concepts that underlie any web framework, and any web application.&lt;/p&gt;

&lt;p&gt;And I actually finished some defined steps in building it! So, yesterday was doubly successful in that I had something to show for it - a small app that I can use (and am actually using) - and in building that app, I deepened my learning in a way that’s difficult to impossible when learning by rote, or working through tutorials. Hope to continue that progress today.&lt;sup&gt;6&lt;/sup&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;sup&gt;1 I wrote an entire blog post, did not save a draft, and lost it in the Great Google Chrome Crash of 2015 (almost as bad as &lt;a href=&quot;http://youtu.be/ynzcUw9wv0E?t=45s&quot;&gt;the Twig of ‘93&lt;/a&gt;). Note to future self - save your work. Note to Tumblr - automatic saving, or at least a way to save a draft without closing out of the post, would be nice! (I assume there’s a reason it’s not there, but man would it have helped here.)&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;2 I’m easily swayed.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;3 In the process, I lost my library eBook of &lt;em&gt;Infinite Jest&lt;/em&gt; - a book I borrowed 3+ months ago and now own the hardcopy of - because I turned on the WiFi. Yes, if you want, you can scam the library into never returning eBooks by just turning the WiFi off. Yes, if you do this, you should probably feel a little bad. But I bought it! It’s just so heavy to bring on the subway!&lt;/sup&gt;&lt;sup&gt;a&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;4 I’m a slow reader.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;5 Or are me in the future, looking back at how naive I was in the past.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;6 Though I’ve already spent like two hours writing this blog post twice.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;a Consider this my plug for &lt;em&gt;Infinite Jest&lt;/em&gt;. I’ll try to never talk about it again - even mentioning it can sound super pretentious.&lt;/sup&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 2, Day 3)1</summary></entry><entry><title type="html">How Do I Learn?</title><link href="http://jimjshields.github.io/programming,/recurse/center,/learning/2015/01/14/how-do-i-learn.html" rel="alternate" type="text/html" title="How Do I Learn?" /><published>2015-01-14T00:00:00-05:00</published><updated>2015-01-14T00:00:00-05:00</updated><id>http://jimjshields.github.io/programming,/recurse/center,/learning/2015/01/14/how-do-i-learn</id><content type="html" xml:base="http://jimjshields.github.io/programming,/recurse/center,/learning/2015/01/14/how-do-i-learn.html">&lt;p&gt;(Hacker School: Week 2, Day 2)&lt;/p&gt;

&lt;p&gt;In my first week here at HS, I felt like I learned a lot. I finished one textbook, read a lot of another one, and by good old &lt;a href=&quot;http://www.imdb.com/title/tt0181739/&quot;&gt;osmosis&lt;/a&gt; I knew everything there was to know about Python. I &lt;a href=&quot;http://en.wikipedia.org/wiki/Pair_programming&quot;&gt;pair programmed&lt;/a&gt; - a technique HS advocates as a way to learn alongside others, regardless of experience level - and had a valuable if challenging experience. I even got to talk to a ton of different people to understand their projects, learning goals, and interests.&lt;/p&gt;

&lt;p&gt;Now we’re in week 2, and that feeling of progress has slowed. It’s easy to feel progress as I’m reading - every page I read and understand os a success. As I’m putting what I’ve learned into action, though, it’s easy for me to get frustrated, unfocused, and discouraged - especially when the implementation of what I learned isn’t as straightforward as I’d like.&lt;/p&gt;

&lt;p&gt;For example - to get a bit technical - on Monday I read all about building an application in Flask. I went through &lt;a href=&quot;http://flask.pocoo.org/docs/0.10/tutorial/&quot;&gt;the tutorial&lt;/a&gt; - a step-by-step guide to building a small app - and understood each piece as I followed along. Yesterday, I went to put what I’d learned into action - I wanted to build a page that tracks my to-do list.&lt;sup&gt;1&lt;/sup&gt; But when I went to start over and build a new app, I got frustrated - I didn’t remember certain steps, new and unfamiliar steps had to be introduced - and eventually got completely discouraged. Worse (in my mind), I know that building this kind of app (where you have a single page, connect to a database, and read and write from the database through the web framework) is about as easy as it gets in web development - a lot of tutorials and help guides try to emphasize how “simple” it is to build this kind of thing. And yet I couldn’t finish it in a day? “You must not be cut out for this, Jim” - me to myself at some sad point yesterday.&lt;/p&gt;

&lt;p&gt;So I took a step back. Why am I frustrated and discouraged? It could be a lot of things, but I think it’s mostly due to the way I like to learn. Traditional learning environments - grade school, high school, college, work - never gave me this kind of frustration. And why? Because my learning was structured by someone else. Here is a textbook - read this chapter - do this assignment - here’s what you did right and wrong (or, for work - here’s what you need to know - do it - good/bad job - try again). If I did something wrong, or didn’t understand something, there is a clear way to better understand it (read it again, do the exercises again, talk to the teacher, get help from a classmate; ask a coworker, talk to the manager, let someone else do it). When I got a good grade, or a good review, that was always, to me, an affirmation that I understood something - and when I got a bad grade/review it was a signal to go back and try again, with some clear, directed feedback. This kind of step-wise learning - learn one thing, ensure understanding, then learn the next, until those successively more difficult pieces build up to the overall course&lt;sup&gt;2&lt;/sup&gt; - was, for me, at least easy to understand. I knew where I stood at any time, I knew how much more there was to learn, I knew what was and was not necessary to understand.&lt;/p&gt;

&lt;p&gt;HS is pointedly non-traditional. Their &lt;a href=&quot;https://www.hackerschool.com/about&quot;&gt;about page&lt;/a&gt; says it all - “We don’t have grades, degrees, classes, or a fixed curriculum.” For me, it’s much easier to learn with grades, degrees, classes, and a fixed curriculum (or defined roles, set expectations/goals, regular reviews); I like having successively harder steps, with an external reward (grades, degrees, promotions, etc.) for getting to that next step. But I want to actively try to adapt to this new learning style - or, at the very least, mesh it with the way I learn. HS advocates this environment for a lot of reasons - but I think the main one is that extrinsic reward systems don’t actually encourage real, lasting learning or engagement with what one is learning. It just makes it a lot harder to start, especially for someone as used to and motivated by the traditional extrinsic reward system as me. So in the coming days, I’d like to get less frustrated and discouraged - and remember that just because I’m not given a grade, or am unable to finish a project, doesn’t mean I haven’t learned something.&lt;sup&gt;3&lt;/sup&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;sup&gt;1 The world needs it.&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;2 &lt;a href=&quot;https://www.hackerschool.com/residents#Mel-Chua&quot;&gt;Mel Chua&lt;/a&gt;, one of HS’s many residents, gave a great talk last week on &lt;a href=&quot;http://blog.melchua.com/2013/06/19/hacker-school-session-engineering-learning-styles/&quot;&gt;learning styles&lt;/a&gt; - specifically in learning programming, but I think it can be generalized. This kind of learning (step-by-step) leans toward what she called Sequential learning - as opposed to Global learning, a style used to describe people who like to be immersed in the big picture. I am aggressively Sequential (it’s a spectrum, but man oh man do I fall on that Sequential side).&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;3 Some things I HAVE learned in the last two days upon some self-reflection: how HTTP really works, why web frameworks exist, why web frameworks maybe shouldn’t exist, how to authenticate users, what hashing is and how to implement it, what WSGI is, how sockets work, what a call stack is, what an ORM is, how to decide when to move on from a project, how to write footnotes.&lt;/sup&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">(Hacker School: Week 2, Day 2)</summary></entry></feed>