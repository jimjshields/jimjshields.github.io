<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Comparing Go &amp; Python | Shields of Dreams</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Comparing Go &amp; Python" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Comparing Go &amp; Python" />
<meta property="og:description" content="Comparing Go &amp; Python" />
<link rel="canonical" href="http://localhost:4000/2020/11/12/rc-day-3-go-vs-python.html" />
<meta property="og:url" content="http://localhost:4000/2020/11/12/rc-day-3-go-vs-python.html" />
<meta property="og:site_name" content="Shields of Dreams" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-11-12T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"Comparing Go &amp; Python","@type":"BlogPosting","url":"http://localhost:4000/2020/11/12/rc-day-3-go-vs-python.html","headline":"Comparing Go &amp; Python","dateModified":"2020-11-12T00:00:00-05:00","datePublished":"2020-11-12T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/11/12/rc-day-3-go-vs-python.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Shields of Dreams" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Shields of Dreams</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Comparing Go &amp; Python</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-11-12T00:00:00-05:00" itemprop="datePublished">Nov 12, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="comparing-go--python">Comparing Go &amp; Python</h2>

<p>I’ve worked mostly in Python for a few years, and it feels like second nature to me. Learning Go this week has forced me to think about some of the major tradeoffs of Python that I’ve taken for granted.</p>

<h3 id="creating-arrays--maps--structs">Creating arrays / maps / structs</h3>

<p>Python:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">my_map</span> <span class="o">=</span> <span class="p">{</span><span class="s">"key1"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"key2"</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
</code></pre></div></div>

<p>Go:</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myArray</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="n">myMap</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">"key1"</span><span class="o">:</span> <span class="m">1</span><span class="p">,</span>
    <span class="s">"key2"</span><span class="o">:</span> <span class="m">2</span>    
<span class="p">}</span>
</code></pre></div></div>

<p>Right away, it was obvious: Go needs more code, and I find the syntax less readable.</p>

<p>On the one hand, it takes me longer to write each line. On the other, it forces me to think about each line, and to make explicit choices about what types each variable will accept.</p>

<p>Like TDD, I found this difficult to start, but enabled much faster iteration as I made progress, and ultimately led to far fewer mistakes than I’m used to. I think this is a worthwhile tradeoff for Go!</p>

<h3 id="checking-if-an-element-is-in-an-array">Checking if an element is in an array</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">my_array</span><span class="p">)</span>  <span class="c1"># True
</span></code></pre></div></div>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myArray</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="c">/// how do I check if 1 is in myArray???</span>
</code></pre></div></div>

<p>I learned, from <a href="https://stackoverflow.com/questions/10485743/contains-method-for-a-slice">this post</a>, that Go doesn’t have the “contains” operation for an array, but it suggests “such a method is trivial to write”. (!)</p>

<p>(along with “just”, “only”, “simple” — “trivial” is one of those words I find difficult in programming. To me, it implies that if I thought about it hard enough, I’ll figure it out! In this case, though, I found it even more frustrating; I like the convenience of a method that someone else wrote, and I don’t think that makes me a worse programmer!)</p>

<p>Turns out, this is how you do it:</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// write your own `contains` function</span>
<span class="n">myArray</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="k">func</span> <span class="n">contains</span><span class="p">(</span><span class="n">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="n">e</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">e</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">myArray</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>  <span class="c">// true</span>
</code></pre></div></div>

<p>Or, you can use a map:</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myMap</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="k">struct</span><span class="p">{}{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">}</span>
<span class="n">value</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">myMap</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">ok</span><span class="p">)</span>  <span class="c">// true</span>
</code></pre></div></div>

<p>I understand the decision to make Go as small and simple as possible — it’s a tradeoff between being useful enough, and having too many features — but I’ll admit that I like the convenience of these kinds of Python features, and I’m glad they made the decision to include these kinds of features.</p>

<h3 id="concurrency">Concurrency</h3>

<p>One goal this week was to learn the basics of concurrency in Go. I’ve worked with concurrency in Python a few times, but know that it’s considered to be fairly difficult compared to other languages, including Go.</p>

<p>I started with a small program — scrape multiple movies from a list of movies on https://letterboxd.com/ — and aimed to do the scraping concurrently.</p>

<p>In the past, with this kind of system, I’ve worked with a queueing architecture, with multiple consumers and producers for one shared jobs queue. Something like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">delay_job</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>  <span class="c1"># sends to a queueing backend, e.g., AWS SQS
</span>

<span class="k">def</span> <span class="nf">process_job</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>  <span class="c1"># receives job from a queueing backend
</span>    <span class="n">process</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</code></pre></div></div>

<p>This has worked well, but is more work: you have to manage a queueing backend.</p>

<p>But I’ve found, in Python, this pattern is easier than writing a concurrent program. Here’s a small example (Python &gt;3.7) that prints out the numbers 0 to 99 concurrently, in a random order:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">job</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">)</span>  <span class="c1"># sleep for a random number of milliseconds
</span>    <span class="k">print</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">enqueue_jobs</span><span class="p">(</span><span class="n">jobs</span><span class="p">):</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">process</span><span class="p">(</span><span class="n">job</span><span class="p">))</span>  <span class="c1"># create a coroutine for each job
</span>        <span class="n">tasks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>  <span class="c1"># wait for all the tasks to finish
</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">enqueue_jobs</span><span class="p">(</span><span class="n">jobs</span><span class="p">))</span>  <span class="c1"># run the loop
</span></code></pre></div></div>
<p>Aside from being fairly new (many of the async features of Python are still maturing), it’s difficult for me to read and think about.</p>

<p>With Go, it’s slightly easier and, I found, more readable:</p>
<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">process</span><span class="p">(</span><span class="n">wg</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">,</span> <span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>  <span class="c">// signal that the job is done, decrementing the counter (`defer` will run this line after everything else in `process`)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="o">/</span> <span class="m">10.0</span><span class="p">))</span>  <span class="c">// sleep for a random number of milliseconds</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>  <span class="c">// declare a group of tasks to wait for; similar to what asyncio.gather provides</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>  <span class="c">// count the number of tasks</span>
        <span class="k">go</span> <span class="n">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>  <span class="c">// run this function as a "goroutine" (concurrently)</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>  <span class="c">// wait for the entire group to finish</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I don’t have an example of this in Python, but I learned that managing goroutine communication is done in <em>channels</em>:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">process</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">jobsChan</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">2</span> <span class="p">)</span> <span class="o">/</span> <span class="m">10.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>  <span class="c">// sleep for a random number of milliseconds</span>
    <span class="n">jobsChan</span> <span class="o">&lt;-</span> <span class="n">i</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">jobsChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">process</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">jobsChan</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="n">jobsChan</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I wrote my small scraper program to use goroutines and channels, and found it easier and faster than writing the same code in Python (once I got the hang of including types everywhere).</p>

<p>So far, I’ve found that Go has an initial learning curve — especially for common Python features I’ve taken for granted — but the static typing and strict compiler have enabled me to iterate much faster and make fewer mistakes, even without writing any tests. I hope I can take some of that learning back to developing in Python!</p>

  </div><a class="u-url" href="/2020/11/12/rc-day-3-go-vs-python.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Shields of Dreams</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Shields of Dreams</li><li><a class="u-email" href="mailto:jim.j.shields@gmail.com">jim.j.shields@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jimjshields"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jimjshields</span></a></li><li><a href="https://www.twitter.com/shieldsofdreams"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">shieldsofdreams</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Jim&#39;s blog. Programming, movies, data, etc.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
